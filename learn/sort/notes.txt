"stable deduplication" vs "sorted deduplication"

different between post-sort dedupelication and pre-sorts
spoilets : post-sorting is better with higher scale (run time complex and space )

pre : runTime klogk           space O(n).   n>=klogk
post: runTime nlogn           space O(1) : resuse same






Phase 1: QuickSort (Start Here!)
Why first?

Most intuitive
Most commonly used
Great introduction to recursion

Learning Resources:

Visual: https://visualgo.net/en/sorting?slide=11
Concept: https://www.youtube.com/watch?v=Hoixgm4-P4M
Go Example: https://yourbasic.org/golang/quicksort-optimizations/

Key Concepts to Understand:

Pivot selection
Partitioning (elements < pivot on left, > pivot on right)
Recursive sorting of sub-arrays

Partition algorithm - Lomuto scheme (the task is to partition the array by assuming last element as pivot element) : choose any element and make it lomuto
In-place sorting - No extra arrays needed
Recursion - Divide and conquer
Pivot selection - Middle element strategy
Invariant maintenance - Elements left < pivot < elements right


Performance Characteristics
Your implementation:

Average: O(n log n) - when pivot divides roughly in half
Worst: O(nÂ²) - when always picking smallest/largest (e.g., already sorted with bad pivot choice)
Space: O(log n) - recursion stack depth
Stable: No - equal elements may swap order


=--------------------------


Phase 2: MergeSort
Learning Resources:

Visual: https://visualgo.net/en/sorting?slide=10
Concept: https://www.youtube.com/watch?v=4VqmGXwpLqc

Key Concepts:

Divide and conquer
Merging two sorted arrays
Recursive splitting

MergeSort algorithm - Divide, conquer, merge
Slice operations - arr[:mid] and arr[mid:]
Recursion base cases - Preventing infinite loops
Stable sorting - Equal elements maintain order
Space complexity - Creating new slices (O(n) space)




Phase 3: HeapSort
Learning Resources:

Visual: https://visualgo.net/en/sorting?slide=12
Heap Structure: https://www.youtube.com/watch?v=2DmK_H7IdTo

Key Concepts:

Binary heap data structure
Heapify operation
Extract max repeatedly

Binary heap data structure 
Array-based tree representation 
Heapify operation 
Max heap vs min heap 
In-place sorting 
Guaranteed O(n log n) 


Phase 4: RadixSort (Most Unique!)
Learning Resources:

Visual: https://visualgo.net/en/sorting?slide=14
Concept: https://www.youtube.com/watch?v=XiuSW_mEn7g

Key Concepts:

Non-comparison based!
Digit-by-digit sorting
Stable sorting of characters


https://www.youtube.com/watch?v=Y95a-8oNqps
idea is to assume current digits' lsb is already sorted. (correct relative order)
7 28            7 40                 7 89
--->            when grouping all 7s
       (728, 740, 789) all sorted

fast af = to make are assumption true we need to sor lsb
28        40        89

and so on ===> we would need to start with lsb (minimal impact of sorts feel)

radix sort doesn't actually care that you're sorting integers, it just needs a lexicographic order between small enough objects - the 8-bit sort of 32-bit integers assumes that 8-bit blocks are lexicographically ordered. So surely radix sort can be extended to work with more general datatypes, so long as we provide a suitable ordering. If we assume a longer string is greater than a smaller one, radix sort on strings is quite straightforward by just sorting prefixes.